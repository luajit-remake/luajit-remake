#include "fps_main.h"
#include "read_file.h"
#include "transactional_output_file.h"
#include "llvm/IRReader/IRReader.h"
#include "deegen_process_bytecode_definition_for_interpreter.h"
#include "deegen_ast_return.h"

#include "json_utils.h"

using namespace dast;

static std::string GetFileNameFromAbsolutePath(const std::string& s)
{
    size_t k = s.find_last_of('/');
    ReleaseAssert(k != std::string::npos);
    return s.substr(k + 1);
}

void FPS_ProcessBytecodeDefinitionForInterpreter()
{
    using namespace llvm;
    std::unique_ptr<LLVMContext> llvmCtxHolder = std::make_unique<llvm::LLVMContext>();
    LLVMContext& ctx = *llvmCtxHolder.get();

    std::string inputFileName = cl_irInputFilename;
    ReleaseAssert(inputFileName != "");

    std::string outputFileName = cl_assemblyOutputFilename;
    ReleaseAssert(outputFileName != "");

    SMDiagnostic llvmErr;
    std::unique_ptr<Module> moduleIn = parseIRFile(inputFileName, llvmErr, ctx);
    if (moduleIn == nullptr)
    {
        fprintf(stderr, "[INTERNAL ERROR] Bitcode for %s cannot be read or parsed.\n", inputFileName.c_str());
        abort();
    }

    ProcessBytecodeDefinitionForInterpreterResult result = ProcessBytecodeDefinitionForInterpreter(std::move(moduleIn));

    std::string contents = CompileLLVMModuleToAssemblyFile(result.m_processedModule.get(), llvm::Reloc::Static, llvm::CodeModel::Small);
    TransactionalOutputFile asmOutFile(outputFileName);
    asmOutFile.write(contents);

    TransactionalOutputFile hdrOutFile(cl_headerOutputFilename);
    FPS_EmitHeaderFileCommonHeader(hdrOutFile.fp());

    fprintf(hdrOutFile.fp(), "#include \"deegen/bytecode_builder_utils.h\"\n\n");
    fprintf(hdrOutFile.fp(), "namespace DeegenBytecodeBuilder {\n\n");
    hdrOutFile.write(result.m_generatedHeaderFile);
    fprintf(hdrOutFile.fp(), "\n} /*namespace DeegenBytecodeBuilder*/\n");

    TransactionalOutputFile jsonOutFile(cl_jsonOutputFilename);
    using json = ::nlohmann::json;
    json j;
    j["header-name"] = GetFileNameFromAbsolutePath(cl_headerOutputFilename);
    j["class-names"] = result.m_generatedClassNames;
    j["cdecl-names"] = result.m_allExternCDeclarations;
    jsonOutFile.write(j.dump(4 /*indent*/));

    asmOutFile.Commit();
    hdrOutFile.Commit();
    jsonOutFile.Commit();
}

void FPS_GenerateBytecodeBuilderAPIHeader()
{
    std::vector<std::string> jsonFileNameList = ParseSemicolonSeparatedFileList(cl_inputListFilenames);
    std::vector<json> jlist;
    for (std::string& filename : jsonFileNameList)
    {
        std::string s = ReadFileContentAsString(filename);
        jlist.push_back(json::parse(s));
    }

    TransactionalOutputFile hdrOutFile(cl_headerOutputFilename);
    FPS_EmitHeaderFileCommonHeader(hdrOutFile.fp());

    fprintf(hdrOutFile.fp(), "#include \"deegen/bytecode_builder_utils.h\"\n\n");
    for (json& j : jlist)
    {
        std::string includeName = JSONCheckedGet<std::string>(j, "header-name");
        fprintf(hdrOutFile.fp(), "#include \"%s\"\n", includeName.c_str());
    }

    fprintf(hdrOutFile.fp(), "\n");

    std::vector<std::string> allClassNames;
    for (json& j : jlist)
    {
        ReleaseAssert(j.count("class-names") && j["class-names"].is_array());
        ReleaseAssert(j.count("cdecl-names") && j["cdecl-names"].is_array());
        ReleaseAssert(j["class-names"].size() == j["cdecl-names"].size());

        for (auto& e : j["class-names"])
        {
            ReleaseAssert(e.is_string());
            allClassNames.push_back(e.get<std::string>());
        }
    }

    {
        std::unordered_set<std::string> checkUnique;
        for (auto& name : allClassNames)
        {
            ReleaseAssert(!checkUnique.count(name));
            checkUnique.insert(name);
        }
    }

    fprintf(hdrOutFile.fp(), "#define GENERATED_ALL_BYTECODE_BUILDER_CLASS_NAMES ");
    for (std::string& name : allClassNames)
    {
        fprintf(hdrOutFile.fp(), "\\\n%s ", name.c_str());
    }

    fprintf(hdrOutFile.fp(), "\n\n\n");

    TransactionalOutputFile cppOutFile(cl_cppOutputFilename);

    // This is a bit hacky and risky, but it should be fine, since the file itself is generated,
    // and it only depends on the bytecode builder header files, which have been generated by now
    //
    fprintf(cppOutFile.fp(), "#define DEEGEN_POST_FUTAMURA_PROJECTION\n");

    fprintf(cppOutFile.fp(), "#pragma clang diagnostic push\n");
    fprintf(cppOutFile.fp(), "#pragma clang diagnostic ignored \"-Wreserved-identifier\"\n");

    fprintf(cppOutFile.fp(), "#include \"deegen/bytecode_builder.h\"\n\n");

    size_t totalSize = 0;
    for (json& j : jlist)
    {
        for (auto& arr : j["cdecl-names"])
        {
            ReleaseAssert(arr.is_array());
            for (auto& x : arr)
            {
                ReleaseAssert(x.is_string());
                std::string s = x.get<std::string>();
                fprintf(cppOutFile.fp(), "extern \"C\" void %s();\n", s.c_str());
                totalSize++;
            }
        }
    }

    fprintf(cppOutFile.fp(), "\nnamespace DeegenBytecodeBuilder {\n\n");

    fprintf(cppOutFile.fp(), "class DeegenInterpreterDispatchTableBuilder {\n");
    fprintf(cppOutFile.fp(), "public:\n");
    fprintf(cppOutFile.fp(), "    static constexpr auto get() {\n");
    fprintf(cppOutFile.fp(), "        using FnPtr = void(*)();\n");
    fprintf(cppOutFile.fp(), "        std::array<FnPtr, %u> r;\n", SafeIntegerCast<unsigned int>(totalSize));
    fprintf(cppOutFile.fp(), "        for (size_t i = 0; i < %u; i++) {\n", SafeIntegerCast<unsigned int>(totalSize));
    fprintf(cppOutFile.fp(), "            r[i] = nullptr;\n");
    fprintf(cppOutFile.fp(), "        }\n");

    for (json& j : jlist)
    {
        ReleaseAssert(j.count("class-names") && j["class-names"].is_array());
        ReleaseAssert(j.count("cdecl-names") && j["cdecl-names"].is_array());
        ReleaseAssert(j["class-names"].size() == j["cdecl-names"].size());

        size_t len = j["class-names"].size();
        for (size_t i = 0; i < len; i++)
        {
            ReleaseAssert(j["class-names"][i].is_string());
            std::string className = j["class-names"][i].get<std::string>();

            ReleaseAssert(j["cdecl-names"][i].is_array());
            auto& arr = j["cdecl-names"][i];
            std::vector<std::string> lis;
            for (auto& x : arr)
            {
                ReleaseAssert(x.is_string());
                lis.push_back(x.get<std::string>());
            }

            fprintf(cppOutFile.fp(), "        {\n");
            fprintf(cppOutFile.fp(), "            static_assert(%s<BytecodeBuilder>::GetNumVariants() == %u);\n", className.c_str(), SafeIntegerCast<unsigned int>(lis.size()));
            fprintf(cppOutFile.fp(), "            constexpr size_t base = BytecodeBuilder::GetBytecodeOpcodeBase<%s<BytecodeBuilder>>();\n", className.c_str());
            for (size_t k = 0; k < lis.size(); k++)
            {
                fprintf(cppOutFile.fp(), "            ReleaseAssert(r[base + %d] == nullptr);\n", static_cast<int>(k));
            }
            for (size_t k = 0; k < lis.size(); k++)
            {
                fprintf(cppOutFile.fp(), "            r[base + %d] = %s;\n", static_cast<int>(k), lis[k].c_str());
            }
            fprintf(cppOutFile.fp(), "        }\n");
        }
    }

    fprintf(cppOutFile.fp(), "        for (size_t i = 0; i < %u; i++) {\n", SafeIntegerCast<unsigned int>(totalSize));
    fprintf(cppOutFile.fp(), "            ReleaseAssert(r[i] != nullptr);\n");
    fprintf(cppOutFile.fp(), "        }\n");
    fprintf(cppOutFile.fp(), "        return r;\n");
    fprintf(cppOutFile.fp(), "    }\n");
    fprintf(cppOutFile.fp(), "};\n");

    fprintf(cppOutFile.fp(), "\n} /*namespace DeegenBytecodeBuilder*/\n\n");

    fprintf(cppOutFile.fp(), "using DispatchTableEntryT = void(*)();\n");
    fprintf(cppOutFile.fp(), "static_assert(sizeof(DispatchTableEntryT) == 8);\n");
    fprintf(cppOutFile.fp(), "constexpr std::array<DispatchTableEntryT, %u> x_tmpDispatchTable = DeegenBytecodeBuilder::DeegenInterpreterDispatchTableBuilder::get();\n", SafeIntegerCast<unsigned int>(totalSize));

    for (size_t i = 0; i < totalSize; i++)
    {
        fprintf(cppOutFile.fp(), "constexpr DispatchTableEntryT x_dispatchTable_entry%u = x_tmpDispatchTable[%u];\n", SafeIntegerCast<unsigned int>(i), SafeIntegerCast<unsigned int>(i));
        fprintf(cppOutFile.fp(), "static_assert(x_dispatchTable_entry%u != nullptr);\n", SafeIntegerCast<unsigned int>(i));
    }

    fprintf(cppOutFile.fp(), "\n");
    fprintf(cppOutFile.fp(), "extern \"C\" const DispatchTableEntryT %s[%u];\n", x_deegen_interpreter_dispatch_table_symbol_name, SafeIntegerCast<unsigned int>(totalSize));
    fprintf(cppOutFile.fp(), "extern \"C\" const DispatchTableEntryT %s[%u] = {\n", x_deegen_interpreter_dispatch_table_symbol_name, SafeIntegerCast<unsigned int>(totalSize));

    for (size_t i = 0; i < totalSize; i++)
    {
        if (i > 0)
        {
            fprintf(cppOutFile.fp(), ",\n");
        }
        fprintf(cppOutFile.fp(), "    x_dispatchTable_entry%u", SafeIntegerCast<unsigned int>(i));
    }
    fprintf(cppOutFile.fp(), "\n};\n");

    fprintf(cppOutFile.fp(), "#pragma clang diagnostic pop\n");

    hdrOutFile.Commit();
    cppOutFile.Commit();
}
